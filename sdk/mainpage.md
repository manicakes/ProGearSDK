# ProGearSDK {#mainpage}

A C SDK for NeoGeo homebrew development targeting the m68000 CPU.

## Quick Start

A minimal program that displays text and a movable sprite:

```c
#include <engine.h>
#include <fix.h>
#include <scene.h>
#include <actor.h>
#include <input.h>
#include <ngres_generated_assets.h>  // Generated by ngres

int main(void) {
    // Initialize all subsystems (arena, palettes, scene, camera, input, audio)
    NGEngineInit();

    // Display title text
    NGFixLayout title = NGFixLayoutAlign(NG_ALIGN_CENTER, NG_ALIGN_TOP);
    NGTextPrint(title, 0, "MY GAME");

    // Create player actor at center of screen
    NGActorHandle player = NGActorCreate(&NGVisualAsset_player, 0, 0);
    NGActorAddToScene(player, FIX(160), FIX(112), 0);
    NGActorSetVisible(player, 1);

    // Game loop
    for (;;) {
        NGEngineFrameStart();  // vblank, watchdog, arena reset, input

        // Move actor with joystick
        if (NGInputHeld(NG_PLAYER_1, NG_BTN_LEFT))  NGActorMove(player, FIX(-2), 0);
        if (NGInputHeld(NG_PLAYER_1, NG_BTN_RIGHT)) NGActorMove(player, FIX(2), 0);
        if (NGInputHeld(NG_PLAYER_1, NG_BTN_UP))    NGActorMove(player, 0, FIX(-2));
        if (NGInputHeld(NG_PLAYER_1, NG_BTN_DOWN))  NGActorMove(player, 0, FIX(2));

        NGEngineFrameEnd();    // scene update, scene draw, menu draw
    }
}
```

## SDK Modules

### Engine (engine.h)

The engine module provides convenience functions for application lifecycle management, consolidating subsystem initialization and main loop boilerplate.

```c
#include <engine.h>

int main(void) {
    // Initialize all subsystems at once:
    // - Arena allocators (persistent, state, frame)
    // - Palette system with default fix palette
    // - Fix layer (cleared)
    // - Scene system
    // - Camera
    // - Input
    // - Audio
    // - Generated palette assets (via weak symbol)
    NGEngineInit();

    // Create game objects...

    for (;;) {
        // Frame start: vblank wait, watchdog kick, frame arena reset, input poll
        NGEngineFrameStart();

        // Your game logic here...

        // Frame end: scene update, scene draw, active menu draw
        NGEngineFrameEnd();
    }
}
```

**Active Menu**: The engine can automatically draw a menu each frame:

```c
// Create menu
NGMenuHandle menu = NGMenuCreate(&ng_arena_state, ...);

// Register for automatic drawing in NGEngineFrameEnd()
NGEngineSetActiveMenu(menu);

// Later, to disable:
NGEngineSetActiveMenu(NULL);
```

**Asset Palette Loading**: `NGEngineInit()` automatically calls `NGPalInitAssets()` if your project includes `ngres_generated_assets.h`. This uses weak symbol linking - the generated function overrides the SDK's no-op default.

### Fix Layer (fix.h)

The fix layer is a 40x32 tile grid overlaying sprites, used for text and HUD elements.

```c
// Simple text at position
NGFixLayout pos = NGFixLayoutXY(5, 10);
NGTextPrint(pos, 0, "SCORE");

// Centered text
NGFixLayout center = NGFixLayoutAlign(NG_ALIGN_CENTER, NG_ALIGN_MIDDLE);
NGTextPrint(center, 0, "GAME OVER");

// Formatted text
NGTextPrintf(pos, 0, "SCORE %d", score);

// Clear a region
NGFixClear(0, 0, 40, 32);
```

See @ref fixfunc and @ref textfunc for all functions.

### Input (input.h)

Handles joystick and button input with edge detection.

```c
NGInputInit();  // Call once at startup (or use NGEngineInit)

// In game loop:
NGInputUpdate();  // Call after vblank (NGEngineFrameStart does this)

// Check button states
if (NGInputPressed(NG_PLAYER_1, NG_BTN_A)) {
    // A button just pressed this frame (use for jump, shoot)
}
if (NGInputHeld(NG_PLAYER_1, NG_BTN_LEFT)) {
    // Left held down (use for movement)
}

// Get direction as -1, 0, or +1
s8 move_x = NGInputGetX(NG_PLAYER_1);
s8 move_y = NGInputGetY(NG_PLAYER_1);

// Charge attacks - how long was button held?
u16 charge = NGInputReleasedFrames(NG_PLAYER_1, NG_BTN_B);
```

Button masks: `NG_BTN_UP`, `NG_BTN_DOWN`, `NG_BTN_LEFT`, `NG_BTN_RIGHT`, `NG_BTN_A`, `NG_BTN_B`, `NG_BTN_C`, `NG_BTN_D`, `NG_BTN_START`

See @ref inputstate and @ref inputdir for all functions.

### Actors (actor.h)

High-level sprite management with animation support. Actor graphics are defined in `assets.yaml` and processed by the `ngres` tool.

```c
// Create actor (NGVisualAsset_xxx defined in ngres_generated_assets.h)
NGActorHandle actor = NGActorCreate(&NGVisualAsset_player, 0, 0);

// Add to scene at position with Z-index (higher Z = in front)
NGActorAddToScene(actor, FIX(100), FIX(50), 0);
NGActorSetVisible(actor, 1);

// Position (fixed-point)
NGActorSetPos(actor, FIX(100), FIX(50));
NGActorMove(actor, FIX(dx), FIX(dy));

// Animation
NGActorSetAnimByName(actor, "walk");
NGActorSetAnim(actor, 0);  // By index
if (NGActorAnimDone(actor)) {
    // Non-looping animation finished
}

// Appearance
NGActorSetHFlip(actor, 1);  // Face left
NGActorSetPalette(actor, new_palette);
NGActorSetVisible(actor, 0);  // Hide

// Cleanup
NGActorRemoveFromScene(actor);
NGActorDestroy(actor);
```

**Coordinate Spaces**: Actors can be world-space (affected by camera) or screen-space (fixed on screen for UI):

```c
// World-space actor (default) - moves with camera
NGActorSetScreenSpace(actor, 0);

// Screen-space actor - fixed position for HUD elements
NGActorSetScreenSpace(actor, 1);
```

See @ref actorlife and @ref actorappear for all functions.

### Scene (scene.h)

The scene manages all actors and parallax layers, handling updates and rendering.

```c
// Initialize scene system (NGEngineInit does this)
NGSceneInit();

// In game loop:
NGSceneUpdate();  // Advance animations
NGSceneDraw();    // Render to VRAM (call during vblank)

// Clear all objects when changing levels
NGSceneReset();
```

### Camera System (camera.h)

The camera controls what portion of the game world is visible on screen. Actors and parallax layers automatically follow the camera.

**Coordinate System**:
- World origin (0,0) is at top-left
- X increases to the right, Y increases downward
- Camera position is the top-left corner of the visible area
- NeoGeo screen is 320x224 pixels (use `NG_CAM_VIEWPORT_WIDTH` and `NG_CAM_VIEWPORT_HEIGHT`)

```c
#include <camera.h>

// Initialize camera at world origin
NGCameraInit();

// Position camera (top-left corner of view)
NGCameraSetPos(FIX(100), FIX(50));

// In game loop:

// Move camera with joystick
s8 dx = NGInputGetX(NG_PLAYER_1);
s8 dy = NGInputGetY(NG_PLAYER_1);
if (dx || dy) {
    NGCameraMove(FIX(dx * 2), FIX(dy * 2));
}

// Keep camera within world bounds
NGCameraClampToBounds(world_width_pixels, world_height_pixels);

// Update camera (handles smooth zoom transitions)
NGCameraUpdate();
```

**Zoom Effects**: The camera supports hardware zoom from 100% down to 50%:

```c
// Instant zoom change
NGCameraSetZoom(NG_CAM_ZOOM_75);  // 75% zoom (shows more world)

// Smooth zoom transition
NGCameraSetTargetZoom(NG_CAM_ZOOM_75);
// Call NGCameraUpdate() each frame to animate

// Check zoom state
if (NGCameraIsZooming()) {
    // Zoom animation in progress
}

// Available zoom levels:
// NG_CAM_ZOOM_100 (16) - 100% full size
// NG_CAM_ZOOM_87  (14) - 87.5%
// NG_CAM_ZOOM_75  (12) - 75%
// NG_CAM_ZOOM_62  (10) - 62.5%
// NG_CAM_ZOOM_50  (8)  - 50% half size
```

**Screen Shake**:

```c
// Start shake effect
NGCameraShake(4, 15);  // Intensity 4, duration 15 frames

// Check if shaking
if (NGCameraIsShaking()) { ... }

// Stop early
NGCameraShakeStop();
```

**Coordinate Transformation**: Convert between world and screen coordinates:

```c
// World position to screen position
s16 screen_x, screen_y;
NGCameraWorldToScreen(world_x, world_y, &screen_x, &screen_y);

// Screen position to world position (e.g., for cursor)
fixed world_x, world_y;
NGCameraScreenToWorld(screen_x, screen_y, &world_x, &world_y);
```

See @ref camsys and @ref camutil for all functions.

### Parallax Layers (parallax.h)

Hardware-accelerated tilemap scrolling using NeoGeo's sprite system. Parallax layers automatically follow the camera with configurable scroll rates.

```c
#include <parallax.h>
#include <ngres_generated_assets.h>

// Create parallax layer from visual asset
NGParallaxHandle bg = NGParallaxCreate(
    &NGVisualAsset_background,
    NG_PARALLAX_WIDTH_INFINITE,  // Infinite width for seamless scrolling
    0,                            // Use asset height
    FIX_FROM_FLOAT(0.5),         // Horizontal parallax (0.5 = half camera speed)
    FIX_FROM_FLOAT(0.5)          // Vertical parallax
);

// Add to scene at viewport position with Z-index
NGParallaxAddToScene(bg, 0, 0, 0);  // Z=0, furthest back

// Create multiple layers for depth
NGParallaxHandle mid = NGParallaxCreate(&NGVisualAsset_midground, ...);
NGParallaxAddToScene(mid, 0, 50, 1);  // Z=1, in front of bg

NGParallaxHandle fg = NGParallaxCreate(&NGVisualAsset_foreground, ...);
NGParallaxAddToScene(fg, 0, 100, 2);  // Z=2, closest

// Cleanup
NGParallaxRemoveFromScene(bg);
NGParallaxDestroy(bg);
```

**Parallax Values**:
- `FIX_FROM_FLOAT(0.0)` - Static, doesn't move
- `FIX_FROM_FLOAT(0.25)` - Slow, distant background
- `FIX_FROM_FLOAT(0.5)` - Medium, mid-ground
- `FIX_ONE` - 1:1 with camera, same as game objects

See @ref parallaxlife for all functions.

### Palettes (palette.h)

The NeoGeo has 256 palettes of 16 colors each. Palettes 0-15 are typically for the fix layer, 16-255 for sprites.

```c
#include <palette.h>
#include <color.h>

// Set individual color (5-bit RGB, 0-31 per channel)
NGPalSetColor(16, 1, NG_RGB(31, 0, 0));  // Bright red

// Set entire palette from array
NGPalSet(16, my_colors);

// Generate gradients
NGPalGradient(16, 1, 8, NG_RGB(0, 0, 31), NG_RGB(31, 31, 31));

// Fade effects (for transitions)
NGPalFadeToBlack(16, amount);  // amount: 0-31
NGPalFadeToWhite(16, amount);

// Background color (visible where no sprites/tiles)
NGPalSetBackdrop(NG_RGB(0, 0, 8));  // Dark blue
```

See @ref palcolor, @ref palgrad, and @ref palfade for all functions.

### Colors (color.h)

Colors are 16-bit: 1 dark bit + 5 bits each for R, G, B (32 shades per channel).

```c
// Construct colors (5-bit components, 0-31)
NGColor red   = NG_RGB(31, 0, 0);
NGColor white = NG_RGB(31, 31, 31);
NGColor black = NG_RGB(0, 0, 0);

// Alternative constructors
NGColor c1 = NG_RGB4(0xF, 0x8, 0x0);  // 4-bit (0-15)
NGColor c2 = NG_RGB8(255, 128, 0);   // 8-bit (0-255, auto-converts)

// Pre-defined colors
NGColor red   = NG_COLOR_RED;
NGColor sky   = NG_COLOR_SKY_BLUE;
NGColor gray  = NG_COLOR_GRAY;

// Extract components
u8 r = NGColorGetRed(color);    // 0-31
u8 g = NGColorGetGreen(color);
u8 b = NGColorGetBlue(color);

// Manipulate colors
NGColor darker = NGColorDarken(color, 8);
NGColor lighter = NGColorLighten(color, 8);
NGColor mixed = NGColorBlend(color1, color2, 128);  // 128 = 50%
NGColor gray = NGColorGrayscale(color);

// Create from HSV
NGColor rainbow = NGColorFromHSV(hue, 255, 255);  // hue: 0-255
```

See @ref colorconstruct and @ref colormanip for all functions.

### Physics (physics.h)

Optional 2D physics with AABB and circle collision shapes.

```c
#include <physics.h>
#include <ngmath.h>

// Create world
NGPhysWorldHandle world = NGPhysWorldCreate();
NGPhysWorldSetGravity(world, 0, FIX(1));  // Downward gravity
NGPhysWorldSetBounds(world, FIX(0), FIX(320), FIX(0), FIX(224));

// Create bodies
NGBodyHandle ball = NGPhysBodyCreateCircle(world, FIX(160), FIX(50), FIX(8));
NGPhysBodySetVel(ball, FIX(2), 0);
NGPhysBodySetRestitution(ball, FIX_ONE);  // Perfect bounce

NGBodyHandle platform = NGPhysBodyCreateAABB(world, FIX(160), FIX(200), FIX(40), FIX(4));
NGPhysBodySetStatic(platform, 1);  // Doesn't move

// Collision callback
void on_collision(NGCollision *col, void *data) {
    // Handle collision between col->body_a and col->body_b
}

// In game loop:
NGPhysWorldUpdate(world, on_collision, NULL);

// Sync actor to physics body
NGVec2 pos = NGPhysBodyGetPos(ball);
NGActorSetPos(ball_actor, pos.x - FIX(8), pos.y - FIX(8));  // Offset to top-left
```

See @ref physworldfn and @ref physbodyfn for all functions.

### Fixed-Point Math (ngmath.h)

The m68000 has no FPU. Use 16.16 fixed-point for fractional values.

```c
#include <ngmath.h>

// Convert to/from fixed
fixed x = FIX(10);              // Integer 10 -> fixed
fixed y = FIX_FROM_FLOAT(2.5);  // Compile-time only
int i = FIX_INT(x);             // fixed -> integer (truncates)

// Arithmetic
fixed sum = a + b;           // Addition is normal
fixed diff = a - b;          // Subtraction is normal
fixed prod = FIX_MUL(a, b);  // Multiplication
fixed quot = FIX_DIV(a, b);  // Division (slow - avoid in loops)

// Constants
fixed one = FIX_ONE;         // 1.0 in fixed-point
fixed half = FIX_HALF;       // 0.5 in fixed-point

// Vectors
NGVec2 pos = {FIX(100), FIX(50)};
NGVec2 vel = {FIX(2), FIX(-1)};
pos = NGVec2Add(pos, vel);
fixed len = NGVec2Length(vel);
NGVec2 norm = NGVec2Normalize(vel);

// Trigonometry (angles are 0-255, not radians)
fixed sin_val = NGSin(angle);  // angle: 0-255 (256 = full circle)
fixed cos_val = NGCos(angle);
u8 angle = NGAtan2(dy, dx);

// Utilities
fixed abs_val = NGAbs(x);
fixed clamped = NGClamp(x, min, max);
s32 sign = NGSign(x);  // -1, 0, or 1
```

See @ref fixed1616, @ref vec2, and @ref trig for all functions.

## Asset Pipeline

The `ngres` tool processes `assets.yaml` to generate:
- C-ROM graphics (sprite and parallax layer tiles)
- V-ROM data (ADPCM audio)
- Palette data
- C header with asset definitions

### Visual Assets

```yaml
visual_assets:
  # Static image
  - name: background
    source: assets/background.png

  # Animated sprite
  - name: player
    source: assets/player.png
    frame_size: [32, 32]
    animations:
      idle: { frames: [0], speed: 1, loop: true }
      walk: { frames: [0-3], speed: 4, loop: true }
      jump: { frames: [4, 5], speed: 2, loop: false }
```

Generates: `NGVisualAsset_player`, `NGVisualAsset_background`

### Palettes

```yaml
palettes:
  # Extract from image
  player_colors:
    source: assets/player.png

  # Manual definition
  custom:
    colors: [0x8000, 0xFFFF, 0x7C00, ...]  # 16 colors in NeoGeo format
```

### Sound Effects and Music

```yaml
# Sound effects (ADPCM-A: 18.5kHz, 6 channels)
sound_effects:
  - name: jump
    source: assets/jump.wav
  - name: hit
    source: assets/hit.wav

# Music (ADPCM-B: variable rate, 1 channel)
music:
  - name: theme
    source: assets/theme.wav
    sample_rate: 22050
    loop: true
```

Run `python3 tools/ngres.py assets.yaml -o build/` to generate assets.

## Main Loop Structure

### Using NGEngine (Recommended)

The simplest approach uses the engine module to handle boilerplate:

```c
#include <engine.h>

int main(void) {
    NGEngineInit();  // Initialize all subsystems

    // Create game objects...

    for (;;) {
        NGEngineFrameStart();  // vblank, watchdog, arena reset, input

        // Your game logic here...

        NGEngineFrameEnd();    // scene update, scene draw, menu draw
    }
}
```

### Manual Control

For full control over timing, call subsystems directly:

```c
for (;;) {
    NGWaitVBlank();       // Wait for vertical blank
    NGWatchdogKick();     // Reset hardware watchdog

    // --- VRAM writes (during vblank) ---
    NGSceneDraw();        // Render scene to VRAM

    // --- Game logic (can extend past vblank) ---
    NGArenaReset(&ng_arena_frame);  // Reset frame allocator
    NGInputUpdate();                // Read controller state

    // Your game logic here...

    NGCameraUpdate();     // Update camera zoom animation
    NGSceneUpdate();      // Advance animations
}
```

## Hardware Limits

| Resource | Limit | Notes |
|----------|-------|-------|
| Screen | 320x224 pixels | Use `NG_CAM_VIEWPORT_WIDTH`, `NG_CAM_VIEWPORT_HEIGHT` |
| Sprites | 381 total | Hardware sprites (used by parallax layers too) |
| Sprites/line | 96 | Maximum sprites on any scanline |
| Fix layer | 40x32 tiles | 28 rows visible on screen |
| Palettes | 256 x 16 colors | 0-15 typically for fix, 16-255 for sprites |
| Colors | 65536 | 15-bit RGB + dark bit |
| C-ROM tiles | 65536 max | Sprite/parallax graphics |
| S-ROM tiles | 8192 max | Fix layer graphics |

## Building

Use the provided demo as a starting point:

```bash
cd demo
make          # Build ROM files
make clean    # Clean build artifacts
```

Output files:
- `mygame-p1.bin` - Program ROM (68000 code)
- `mygame-c1.bin`, `mygame-c2.bin` - Sprite graphics
- `mygame-s1.bin` - Fix layer graphics
- `mygame-m1.bin` - Sound driver (Z80 code)
- `mygame-v1.bin` - Audio samples

To run in MAME, zip the ROM files into a romset and place in your MAME roms directory along with `neogeo.zip` (BIOS).
